"""Generated by claude

Hey! I'm totally down to vibe code with you! ðŸŽµ

To get us started on the right track, I need to know:

1. **What kind of project** are you thinking? (web app, game, tool, creative coding, etc.)
2. **What's your vibe** - something chill and experimental, or do you have a specific goal in mind?

Once I know what direction you're feeling, I can dive right in with an artifact and we can build something cool together! No need for uploads unless you have something specific you want to work with.

What's calling to you right now?

>>> The project is python backend app financial market: options, futures for stock, commodities, crypto

Nice! Financial markets backend - that's a solid project. Let me ask a couple key questions to nail the vibe:

1. **What's the main focus** - are we building something to fetch/analyze market data, calculate option pricing (Black-Scholes etc.), manage portfolios, or execute trades?

2. **Which data source** are you thinking? (free APIs like Alpha Vantage, Yahoo Finance, or do you have premium access to something like Bloomberg/Interactive Brokers?)

I'm thinking we could start with a clean Python class structure for handling different instrument types (stocks, options, futures, crypto) and build out from there. Could make it modular so you can easily add new features.

What's your main use case - research, backtesting, live trading, or just exploring the data?

>>> data source is local parquet files and main focus on option pricing

Perfect! Options pricing with local parquet data - love it. Let me build us a solid foundation for options pricing models with parquet data handling.

I'll create a modular Python backend that can:
- Load market data from parquet files
- Implement Black-Scholes and other pricing models
- Handle different underlying assets (stocks, crypto, commodities)
- Calculate Greeks (delta, gamma, theta, etc.)There we go! Built you a clean options pricing backend that handles:

**Core Features:**
- **Modular design** - easy to add new models (Monte Carlo, binomial trees, etc.)
- **Black-Scholes pricing** with full Greeks calculation
- **Parquet data loading** with caching and date filtering
- **Multi-asset support** (stocks, crypto, commodities)
- **Realized volatility** calculation from historical data

**Key Classes:**
- `DataLoader` - handles your parquet files
- `OptionsPricer` - main engine that orchestrates everything
- `BlackScholesModel` - pricing model (easy to extend)

The code expects your parquet files in a structure like:
- `AAPL_spot.parquet` (with price column + datetime index)
- `AAPL_options_20241220.parquet` (for options chains)

Want to extend this? We could add:
- Implied volatility calculation
- Monte Carlo pricing for exotic options
- Binomial/trinomial tree models
- Portfolio-level Greeks aggregation
- Real-time data streaming

What part should we dive deeper into or what would you like to build on top of this?


"""
import pandas as pd
import numpy as np
from scipy.stats import norm
from dataclasses import dataclass
from typing import Optional, Dict, Any, List
from pathlib import Path
import logging
from datetime import datetime, timedelta

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class OptionContract:
    """Represents an option contract"""
    symbol: str
    underlying: str
    strike: float
    expiry: datetime
    option_type: str  # 'call' or 'put'
    style: str = 'european'  # 'american' or 'european'

@dataclass
class MarketData:
    """Market data for pricing"""
    spot_price: float
    volatility: float
    risk_free_rate: float
    dividend_yield: float = 0.0
    timestamp: datetime = None

class DataLoader:
    """Handles loading market data from parquet files"""

    def __init__(self, data_path: str):
        self.data_path = Path(data_path)
        self.cache = {}

    def load_spot_data(self, symbol: str, date_range: Optional[tuple] = None) -> pd.DataFrame:
        """Load spot price data for underlying asset"""
        file_path = self.data_path / f"{symbol}_spot.parquet"

        if not file_path.exists():
            raise FileNotFoundError(f"No spot data found for {symbol}")

        df = pd.read_parquet(file_path)

        if date_range:
            start, end = date_range
            df = df[(df.index >= start) & (df.index <= end)]

        logger.info(f"Loaded {len(df)} spot records for {symbol}")
        return df

    def load_options_chain(self, underlying: str, expiry: datetime) -> pd.DataFrame:
        """Load options chain data"""
        file_path = self.data_path / f"{underlying}_options_{expiry.strftime('%Y%m%d')}.parquet"

        if file_path.exists():
            df = pd.read_parquet(file_path)
            logger.info(f"Loaded options chain for {underlying} expiring {expiry}")
            return df
        else:
            logger.warning(f"No options chain found for {underlying} expiring {expiry}")
            return pd.DataFrame()

    def calculate_realized_volatility(self, symbol: str, lookback_days: int = 30) -> float:
        """Calculate realized volatility from historical data"""
        df = self.load_spot_data(symbol)

        if len(df) < lookback_days:
            raise ValueError(f"Not enough data for volatility calculation")

        # Use log returns
        returns = np.log(df['price'] / df['price'].shift(1)).dropna()
        recent_returns = returns.tail(lookback_days)

        # Annualized volatility
        vol = recent_returns.std() * np.sqrt(252)
        logger.info(f"Calculated {lookback_days}d realized vol for {symbol}: {vol:.2%}")

        return vol

class BlackScholesModel:
    """Black-Scholes option pricing model"""

    @staticmethod
    def calculate_d1_d2(S: float, K: float, T: float, r: float, q: float, sigma: float):
        """Calculate d1 and d2 parameters"""
        d1 = (np.log(S/K) + (r - q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
        d2 = d1 - sigma * np.sqrt(T)
        return d1, d2

    @classmethod
    def price(cls, option: OptionContract, market_data: MarketData) -> float:
        """Calculate Black-Scholes option price"""
        S = market_data.spot_price
        K = option.strike
        T = (option.expiry - datetime.now()).days / 365.0  # Time to expiry in years
        r = market_data.risk_free_rate
        q = market_data.dividend_yield
        sigma = market_data.volatility

        if T <= 0:
            # Expired option
            if option.option_type.lower() == 'call':
                return max(S - K, 0)
            else:
                return max(K - S, 0)

        d1, d2 = cls.calculate_d1_d2(S, K, T, r, q, sigma)

        if option.option_type.lower() == 'call':
            price = S * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
        else:  # put
            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * np.exp(-q * T) * norm.cdf(-d1)

        return max(price, 0)

    @classmethod
    def greeks(cls, option: OptionContract, market_data: MarketData) -> Dict[str, float]:
        """Calculate option Greeks"""
        S = market_data.spot_price
        K = option.strike
        T = (option.expiry - datetime.now()).days / 365.0
        r = market_data.risk_free_rate
        q = market_data.dividend_yield
        sigma = market_data.volatility

        if T <= 0:
            return {'delta': 0, 'gamma': 0, 'theta': 0, 'vega': 0, 'rho': 0}

        d1, d2 = cls.calculate_d1_d2(S, K, T, r, q, sigma)

        # Delta
        if option.option_type.lower() == 'call':
            delta = np.exp(-q * T) * norm.cdf(d1)
        else:
            delta = -np.exp(-q * T) * norm.cdf(-d1)

        # Gamma (same for calls and puts)
        gamma = np.exp(-q * T) * norm.pdf(d1) / (S * sigma * np.sqrt(T))

        # Theta
        theta1 = -S * norm.pdf(d1) * sigma * np.exp(-q * T) / (2 * np.sqrt(T))
        theta2 = -r * K * np.exp(-r * T) * norm.cdf(d2 if option.option_type.lower() == 'call' else -d2)
        theta3 = q * S * np.exp(-q * T) * norm.cdf(d1 if option.option_type.lower() == 'call' else -d1)

        if option.option_type.lower() == 'call':
            theta = (theta1 + theta2 + theta3) / 365  # Per day
        else:
            theta = (theta1 - theta2 - theta3) / 365  # Per day

        # Vega (same for calls and puts)
        vega = S * np.exp(-q * T) * norm.pdf(d1) * np.sqrt(T) / 100  # Per 1% vol change

        # Rho
        if option.option_type.lower() == 'call':
            rho = K * T * np.exp(-r * T) * norm.cdf(d2) / 100  # Per 1% rate change
        else:
            rho = -K * T * np.exp(-r * T) * norm.cdf(-d2) / 100

        return {
            'delta': delta,
            'gamma': gamma,
            'theta': theta,
            'vega': vega,
            'rho': rho
        }

class OptionsPricer:
    """Main options pricing engine"""

    def __init__(self, data_loader: DataLoader):
        self.data_loader = data_loader
        self.models = {
            'black_scholes': BlackScholesModel
        }

    def get_market_data(self, underlying: str, vol_override: Optional[float] = None) -> MarketData:
        """Get current market data for underlying"""
        # Load latest spot price
        spot_df = self.data_loader.load_spot_data(underlying)
        current_spot = spot_df['price'].iloc[-1]

        # Calculate or use override volatility
        if vol_override:
            volatility = vol_override
        else:
            volatility = self.data_loader.calculate_realized_volatility(underlying)

        # You'd typically load these from data or config
        risk_free_rate = 0.05  # 5% default
        dividend_yield = 0.0   # 0% default

        return MarketData(
            spot_price=current_spot,
            volatility=volatility,
            risk_free_rate=risk_free_rate,
            dividend_yield=dividend_yield,
            timestamp=datetime.now()
        )

    def price_option(self, option: OptionContract, model: str = 'black_scholes',
                    vol_override: Optional[float] = None) -> Dict[str, Any]:
        """Price a single option"""
        market_data = self.get_market_data(option.underlying, vol_override)

        model_class = self.models.get(model.lower())
        if not model_class:
            raise ValueError(f"Model {model} not supported")

        price = model_class.price(option, market_data)
        greeks = model_class.greeks(option, market_data)

        return {
            'price': price,
            'greeks': greeks,
            'market_data': market_data,
            'model_used': model
        }

    def price_options_chain(self, underlying: str, expiry: datetime,
                           strikes: List[float], model: str = 'black_scholes') -> pd.DataFrame:
        """Price an entire options chain"""
        results = []

        for strike in strikes:
            # Price both call and put
            for option_type in ['call', 'put']:
                option = OptionContract(
                    symbol=f"{underlying}_{expiry.strftime('%Y%m%d')}_{strike}_{option_type[0].upper()}",
                    underlying=underlying,
                    strike=strike,
                    expiry=expiry,
                    option_type=option_type
                )

                pricing_result = self.price_option(option, model)

                result = {
                    'underlying': underlying,
                    'strike': strike,
                    'expiry': expiry,
                    'option_type': option_type,
                    'price': pricing_result['price'],
                    'spot_price': pricing_result['market_data'].spot_price,
                    **pricing_result['greeks']
                }
                results.append(result)

        return pd.DataFrame(results)

# Example usage
if __name__ == "__main__":
    # Initialize
    data_loader = DataLoader("./market_data")  # Your parquet files directory
    pricer = OptionsPricer(data_loader)

    # Create an option contract
    option = OptionContract(
        symbol="AAPL_20241220_150_C",
        underlying="AAPL",
        strike=150.0,
        expiry=datetime(2024, 12, 20),
        option_type="call"
    )

    # Price the option
    try:
        result = pricer.price_option(option)
        print(f"Option Price: ${result['price']:.2f}")
        print("Greeks:")
        for greek, value in result['greeks'].items():
            print(f"  {greek.capitalize()}: {value:.4f}")

    except FileNotFoundError as e:
        print(f"Data file not found: {e}")
        print("Make sure your parquet files are in the './market_data' directory")
        print("Expected format: {symbol}_spot.parquet with columns ['price', datetime index]")
